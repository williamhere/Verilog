統整程式
module topmodule(clk,rstreq,ewr,ead,edat,zr);
input clk, rstreq, ewr; 
input [4:0] ead;
input [7:0] edat; 

output zr; 

wire zr; 
wire ldac, ldir;
wire clk1, clk2, fch, rst; 
wire [7:0] alu_out, acc_out; 
wire [7:0] mdat;
wire [4:0] adir, adpc, admem;
wire [2:0] opcd; 
wire ldpc, pclk, aclk, mrd, mwr;

iobuffer io1( .clk2(clk2), .mrd(mrd) , .fch(fch), .alu_out(alu_out), .mdat(mdat));
accum accum1( .clk(clk), .rst(rst), .alu_out(alu_out), .ldac(ldac) , .acc_out(acc_out));
clkgen clkgen1( .clk(clk), .rstreq(rstreq), .clk1(clk1), .clk2(clk2), .fch(fch), .rst(rst));
decode decoder1( .clk1(clk1), .clk2(clk2), .fch(fch), .rst(rst), .opcd(opcd), 
.ldir(ldir),.ldac(ldac),.mrd(mrd),.mwr(mwr),.ldpc(ldpc),.pclk(pclk),.aclk(aclk));
instreg instreg1( .clk(clk) , .rst(rst), .ldir(ldir), .mdat(mdat), .adir(adir), .opcd(opcd));
alu alu1( .aclk(aclk) , .mdat(mdat) , .acc_out(acc_out) , .opcd(opcd) ,
.alu_out(alu_out) , .zr(zr) );
memory mem1(.rst(rst) , .mrd(mrd) , .mwr(mwr) , .ewr(ewr), .mad(admem),
.ead(ead), .edat(edat), .mdat(mdat));
pc pc1( .pclk(pclk), .rst(rst), .adir(adir), .ldpc(ldpc), .adpc(adpc));
mux2_1 mux2( .adir(adir), .adpc(adpc), .fch(fch) , .admem(admem));

endmodule






module testtopmodule;

reg clk, rstreq, ewr; 
reg [4:0] ead;
reg [7:0] edat; 

wire zr;

reg [7:0] memr [31:0] ; 
reg [4:0] i=15;
reg [4:0] j;

topmodule test(clk,rstreq,ewr,ead,edat,zr);

initial
begin

memr[0]={3'b101,5'd20};//load
memr[1]={3'b010,5'd21};//add
memr[2]={3'b110,5'd22};//store
memr[3]={3'b101,5'd23};//load
memr[4]={3'b011,5'd24};//and
memr[5]={3'b110,5'd25};//store
memr[6]={3'b111,5'd10};//jump
memr[10]={3'b101,5'd26};//load
memr[11]={3'b100,5'd27};//xor
memr[12]={3'b110,5'd28};//store
memr[13]={3'b001,5'd0};//skip
memr[14]={3'b000,5'd0};//halt
memr[20]={8'd10};//data
memr[21]={8'd30};
memr[22]={8'd10};
memr[23]={8'd16};
memr[24]={8'd15};
memr[25]={8'd0};
memr[26]={8'd12};
memr[27]={8'd24};
memr[28]={8'd0};


clk=0; ewr=1'b1; rstreq=1'b0;
j=i;
#10;

repeat(i+1)
begin
edat = memr [j] ; 
ead=j;
j=j-1;
#20;
end

ewr=1'b0; rstreq=1'b1;
end

always
begin
#20 clk=~clk;
end


endmodule



多工器

module mux2_1( adir, adpc, fch, admem);
input [4:0] adir, adpc;                  //address Instruction register //address program counter
input fch;
output [4:0] admem;                      //address memory
reg [4:0] admem;

always @ (fch,adpc,adir) begin
case (fch)
1'b1 : admem = adpc;
1'b0 : admem = adir;
endcase end
endmodule



















module testmux2_1;
reg [4:0] adir, adpc;
reg fch;
wire [4:0] admem;

mux2_1 test( adir, adpc, fch, admem);

initial 
$monitor($time,"adir=%h adpc=%h fch=%b admem=%h",adir, adpc, fch, admem);

initial  
begin
adir=5'h01; adpc=5'h02;
fch=1'b0; 
#50;
fch=1'b1;
#50;

end 
endmodule


記憶體
module memory(rst,mrd,mwr,ewr,mad,ead,edat,mdat);

input rst, mrd, mwr, ewr; 
input [4:0] mad, ead; 
input [7:0] edat;
inout [7:0] mdat; 

reg [7:0] memr [4095:0] ; 
reg [7:0] temp;
// edata: external data, mdata: CPU-memory data

always @(*) begin
if (!rst) begin if(ewr == 1) memr[ead] <= edat; end

else if(mwr == 1)  memr[mad] <= mdat; 
else if (mrd == 1) temp <= memr[mad]; 
else temp <= 'bzzzzzzzz; 
end

assign mdat = temp;
endmodule






module testmemory;

reg rst, mrd, mwr, ewr; 
reg [4:0] mad,ead; 
reg [7:0] edat,mdat_in;
reg mdat_write;

wire [7:0] mdat; 

assign mdat=mdat_write?mdat_in:'bz;                 //??mdat??????,???????


memory test(rst,mrd,mwr,ewr,mad,ead,edat,mdat);




initial begin
rst=1'b1; mrd=1'b0; mwr=1'b0; ewr=1'b0; mad=5'h00; ead=5'h00; edat=8'h00; mdat_write=1'b0; mdat_in=8'h00;
#20;

rst=1'b0; ewr=1'b1; ead=5'h00; edat=8'h01;
#20;


rst=1'b1; mwr=1'b1; mad=5'h01; mdat_write=1'b1; mdat_in=8'h32;
#20;
rst=1'b1; mwr=1'b1; mad=5'h02; mdat_write=1'b1; mdat_in=8'h64;
#20;
mwr=1'b0;

rst=1'b1; mrd=1'b1; mad=5'h00; mdat_write=1'b0;
#20;
rst=1'b1; mrd=1'b1; mad=5'h01; mdat_write=1'b0;
#20;
rst=1'b1; mrd=1'b1; mad=5'h02; mdat_write=1'b0;
#20;
mrd=1'b0;
#20;

end
endmodule



指令暫存器
module instreg(clk,rst,ldir,mdat,adir,opcd);
input clk, ldir, rst; 
input [7:0] mdat;

output [4:0] adir; 
output [2:0] opcd;

reg [4:0] adir; 
reg [2:0] opcd;

always @(posedge clk or negedge rst) begin

if (!rst) begin opcd <= 0; adir <= 0; end
else if (ldir == 1) begin opcd <= mdat[2:0] ; adir <= mdat[7:3] ; end


end
endmodule





module testinstreg;

reg clk, ldir, rst; 
reg [7:0] mdat;
wire [4:0] adir; 
wire [2:0] opcd;

instreg test(clk,rst,ldir,mdat,adir,opcd);

initial 
$monitor($time,"clk=%b rst=%b ldir=%b mdat=%h adir=%h opcd=%h",clk,rst,ldir,mdat,adir,opcd);

initial
begin
mdat=8'h23;
end

initial 
begin
clk=1'b0;
forever #10 clk=~clk;
end

initial 
begin
rst=1'b0;
#20 rst=1'b1;
end

initial 
begin
ldir=1'b0;
#20 ldir=1'b1;
end

initial
#200 $finish;

endmodule





哀喔buffer
module iobuffer(clk2,mrd,fch,alu_out,mdat);

input clk2,mrd,fch;
input [7:0] alu_out;

output [7:0] mdat;

wire en, en1;

assign en = (mrd || fch || clk2);
assign en1 = ~en;
assign mdat = (en1) ? alu_out : 8'hzz ;
endmodule






module testiobuffer;

reg clk2,mrd,fch;
reg [7:0] alu_out;

wire [7:0] mdat;

iobuffer test(clk2,mrd,fch,alu_out,mdat);

initial 
$monitor($time,"clk=%b mrd=%b fch=%h alu_out=%h mdat=%h",clk2,mrd,fch,alu_out,mdat);

initial
begin
alu_out=8'h23;
end

initial 
begin
clk2=1'b0; fch=1'b1;mrd=1'b0;#50;
clk2=1'b0; fch=1'b0;mrd=1'b1;#50;
clk2=1'b0; fch=1'b0;mrd=1'b0;#50;
clk2=1'b1; fch=1'b1;mrd=1'b1;
end


initial
#200 $finish;

endmodule



clock訊號~
module clkgen(clk,rstreq,clk1,clk2,fch,rst);
input clk,rstreq; 
output reg clk1,clk2,fch,rst;

wire c1;

assign c1 = clk && clk;
always @(clk or rstreq)begin 
clk1=c1;
rst=rstreq;
end

always @(negedge c1 or negedge rstreq) begin
if(!rstreq) 
clk2 <=1'b0; 
else 
clk2 <= ~clk2 ; 
end

always @(posedge clk2 or negedge rstreq) begin
if(!rstreq) 
fch<=1'b0 ;
else 
fch<=~fch ; 
end

endmodule

//----------test-----------------
module testclkgen;

reg clk,rstreq; 
wire clk1,clk2,fch,rst;
clkgen test(clk,rstreq,clk1,clk2,fch,rst);

initial 
$monitor($time,"clk1=%b clk2=%b fch=%b rst=%b clk=%b rstreq=%b",clk1,clk2,fch,rst,clk,rstreq);

initial 
begin
clk=1'b0;
forever #10 clk=~clk;
end

initial 
begin
rstreq=1'b0;
#20 rstreq=1'b1;
#200 $finish;
end

endmodule
//-------------------------------

解碼器
module decode(clk1,clk2,fch,rst,opcd,ldir,ldac,mrd,mwr,ldpc,pclk,aclk);

input clk1, clk2, rst, fch; 
input [2:0] opcd;

output ldir, ldac, mrd, mwr, ldpc, pclk, aclk;

reg aclk; wire [2:0] seq; 
reg [7:0] dout;

assign seq = {clk1,clk2,fch};

always @(*) begin
if(!rst) dout = 0; 
else begin
case(seq) 
3'b011 : dout = 6'b000000;
3'b111 : dout = 6'b000010;
3'b001 : dout = 6'b000011;
3'b101 : dout = 6'b000011;
3'b010 : dout = 6'b000000;
3'b110 : begin

case(opcd) 
3'b010 : dout = 6'b100010;
3'b011 : dout = 6'b100010;
3'b100 : dout = 6'b100010;
3'b101 : dout = 6'b100010;
default: dout = 6'b100000; 
endcase 
end

3'b000 : begin 
case(opcd)
3'b010 : dout = 6'b010010;
3'b011 : dout = 6'b010010;
3'b100 : dout = 6'b010010; 
3'b101 : dout = 6'b010010; 
3'b110 : dout = 6'b000100; 
3'b001 : dout = 6'b100000; 
3'b111 : dout = 6'b001000;
default: dout = 6'b000000; 
endcase
end 

3'b100 : begin 
case(opcd)
3'b010 : dout = 6'b010010;
3'b011 : dout = 6'b010010;
3'b100 : dout = 6'b010010; 
3'b101 : dout = 6'b010010; 
3'b001 : dout = 6'b100000; 
3'b111 : dout = 6'b101000; 
3'b110 : dout = 6'b000100; 
default: dout = 6'b000000; 

endcase
end 
endcase
end
end

assign ldir = dout[0]; 
assign mrd  = dout[1];
assign mwr  = dout[2]; 
assign ldpc = dout[3];
assign ldac = dout[4]; 
assign pclk = dout[5];

always @(*) begin

if(!rst) begin aclk = 0; end
else begin
case(seq) 3'b100 : aclk = 0;

default : aclk = 1; 
endcase
end
end
endmodule












module testdecode;


reg clk1, clk2, rst, fch; 
reg [2:0] opcd;

wire ldir, ldac, mrd, mwr, ldpc, pclk, aclk;

decode test(clk1,clk2,fch,rst,opcd,ldir,ldac,mrd,mwr,ldpc,pclk,aclk);

initial 
$monitor($time,"clk1=%b clk2=%b fch=%b rst=%h opcd=%b ldir=%b ldac=%b mrd=%b mwr=%b ldpc=%b pclk=%b aclk=%b",clk1,clk2,fch,rst,opcd,ldir,ldac,mrd,mwr,ldpc,pclk,aclk);

initial
begin
clk1=1'b0;
clk2=1'b0;
fch=1'b0;
opcd=3'b000;
end

initial
begin
rst=1'b0;
#10;
rst=1'b1;
end

initial
begin
#10;
clk1=1'b0; clk2=1'b0; fch=1'b0;
opcd=3'b010; #5;
opcd=3'b011; #5;
opcd=3'b100; #5;
opcd=3'b101; #5;
opcd=3'b001; #5;
opcd=3'b111; #5;
opcd=3'b110; 
end

initial
begin
#45;
clk1=1'b1; clk2=1'b0; fch=1'b0;
opcd=3'b010; #5;
opcd=3'b011; #5;
opcd=3'b100; #5;
opcd=3'b101; #5;
opcd=3'b001; #5;
opcd=3'b111; #5;
opcd=3'b110; 
end

initial
begin
#80;
clk1=1'b1; clk2=1'b1; fch=1'b0;
opcd=3'b010; #5;
opcd=3'b011; #5;
opcd=3'b100; #5;
opcd=3'b101; #5;
opcd=3'b001; #5;
opcd=3'b111; #5;
opcd=3'b110; 
end


initial
begin
#115;
clk1=1'b0; clk2=1'b0; fch=1'b1;
#10;
clk1=1'b0; clk2=1'b1; fch=1'b0;
#10;
clk1=1'b0; clk2=1'b1; fch=1'b1;
#10;
clk1=1'b1; clk2=1'b0; fch=1'b1;
#10;
clk1=1'b1; clk2=1'b1; fch=1'b1;
end


initial
#160 $finish;

endmodule

算術邏輯單元
module alu (aclk,mdat,acc_out,opcd,alu_out,zr);

input aclk; 
input [7:0] mdat, acc_out; 
input [2:0] opcd;

output [7:0] alu_out; 
output zr;

reg [7:0] alu_out; 
wire zr;

always @ ( posedge aclk ) begin
case (opcd) 3'b000 : begin alu_out <= acc_out; end
3'b001 : begin alu_out <= acc_out; end
3'b010 : begin alu_out <= {mdat + acc_out}; end
3'b011 : begin alu_out <= {mdat & acc_out}; end
3'b100 : begin alu_out <= {mdat ^ acc_out}; end
3'b101 : begin alu_out <= mdat; end
3'b110 : begin alu_out <= acc_out; end
3'b111 : begin alu_out <= acc_out; end
default : begin alu_out <= 0; end
endcase end


assign zr = ~|(alu_out);

endmodule

程式計數器

module pc( pclk, rst, adir, ldpc, adpc);

input pclk, rst, ldpc; 
input [4:0] adir;

output [4:0] adpc;

reg [4:0] temp1;

always @ (posedge pclk or negedge rst) begin
if (!rst) begin temp1 <= 0; end

else if ( ldpc == 1) begin temp1 <= adir; end
else begin temp1 <= temp1 + 1; end

end

assign adpc = temp1;

endmodule




module testpc;

reg pclk, rst, ldpc; 
reg [4:0] adir;
wire [4:0] adpc;

pc test( pclk, rst, adir, ldpc, adpc);


initial 
$monitor($time,"pclk=%b rst=%b adir=%h ldpc=%b adpc=%h",pclk, rst, adir, ldpc, adpc);


initial
begin
adir=5'h13;
end

initial 
begin
pclk=1'b0;
forever #10 pclk=~pclk;
end

initial 
begin
rst=1'b0;
#20 rst=1'b1;
#200 $finish;
end

initial 
begin
ldpc=1'b0;
#100 ldpc=1'b1;


end
endmodule

積累器

module accum(clk, rst, alu_out, ldac, acc_out);

input clk, rst, ldac;
input [7:0] alu_out;

output [7:0] acc_out; 

reg [7:0] acc_out;

always @ (posedge clk or negedge rst) begin
if (!rst) begin
acc_out <= 0;
end 

else if ( ldac == 1) begin
acc_out <= alu_out[7:0];
end

end
endmodule





module testaccum;
reg clk, rst, ldac;
reg [7:0] alu_out;
wire [7:0] acc_out; 

accum test(clk, rst, alu_out, ldac, acc_out);

initial 
$monitor($time,"clk=%b rst=%b ldac=%b alu_out=%h acc_out=%h",clk, rst, ldac, alu_out, acc_out);

initial
begin
alu_out=8'h23;
end

initial 
begin
clk=1'b0;
forever #10 clk=~clk;
end

initial 
begin
rst=1'b0;
#20 rst=1'b1;
end

initial 
begin
ldac=1'b0;
#40 ldac=1'b1;
end

initial
#200 $finish;

endmodule